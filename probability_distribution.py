# -*- coding: utf-8 -*-
"""Probability distribution.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Vtlfd46KWrQTKHIXtdSzTUMorQKE3ylH

# **Bionomial Distribution**
"""

import pandas as pd
import numpy as np
import seaborn as sn
import matplotlib.pyplot as plt
from scipy import stats
stats.binom.pmf(5, 10, 0.1)

pmf_df = pd.DataFrame({'success': range(0,21), 'pmf': list(stats.binom.pmf(range(0,21),20, 0.1))})
sn.barplot(x = pmf_df.success, y = pmf_df.pmf)
plt.ylabel('pmf')
plt.xlabel('Number of items returned');

stats.binom.cdf(5, 20, 0.1)

mean, var = stats.binom.stats(20, 0.1)
print("Average:  ", mean , "Variance: ", var)

"""# **Poisson Distribution**"""

stats.poisson.cdf(5, 10)

pmf_df = pd.DataFrame({'success': range(0,30), 'pmf': list(stats.poisson.pmf(range(0,30), 10))})
#creating a barplot with no of calls as x and pmf as y
sn.barplot(x =pmf_df.success, y = pmf_df.pmf);
plt.xlabel('Numver of calls Recieved');

"""# **Exponential Distribution**"""

#Calculate the probability that the system will fail before 1000 hours
stats.expon.cdf(1000,
                loc = 1/1000,
                scale = 1000)

#calculate the time by which 10% of the system will fail( calculate p10 life)
#This is calculated by ppf(percent point function)
stats.expon.ppf(.1,
                loc = 1 / 1000,
                scale = 1000 )

pdf_df = pd.DataFrame({'success': range(0, 5000, 100),
                       'pdf':
                       list(stats.expon.pdf(range(0, 5000, 100),
                                            loc =  1/1000,
                                            scale = 1000))})
plt.figure(figsize=(10,4))
sn.barplot(x = pdf_df.success, y =  pdf_df.pdf)
plt.xticks(rotation=90);
plt.xlabel('Time to failure');

"""# **Normal Distribution**"""

from google.colab import files

uploaded = files.upload()

for fn in uploaded.keys():
  print('User uploaded file "{name}" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))

from google.colab import files

uploaded = files.upload()

for fn in uploaded.keys():
  print('User uploaded file "{name}" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))

import warnings

beml_df = pd.read_csv('BEML.csv')
beml_df[0:5]

glaxo_df = pd.read_csv('GLAXO.csv')
glaxo_df[0:5]

beml_df = beml_df[['Date', 'Close']]
glaxo_df = glaxo_df[['Date', 'Close']]

glaxo_df = glaxo_df.set_index(pd.DatetimeIndex(glaxo_df['Date']))
beml_df = beml_df.set_index(pd.DatetimeIndex(beml_df['Date']))

glaxo_df.head(5)

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

plt.plot(glaxo_df.Close);
plt.xlabel('Time');
plt.ylabel('Close Price');

plt.plot(beml_df.Close);
plt.xlabel('Time');
plt.ylabel('Close');

glaxo_df['gain'] = glaxo_df.Close.pct_change(periods = 1)
beml_df['gain'] = beml_df.Close.pct_change(periods= 1)
glaxo_df.head(5)

glaxo_df = glaxo_df.dropna()
beml_df = beml_df.dropna()

plt.figure(figsize= (8,6));
plt.plot(glaxo_df.index, glaxo_df.gain);
plt.xlabel('Time');
plt.ylabel('gain');

sn.distplot(glaxo_df.gain, label = 'Glaxo');
sn.distplot(beml_df.gain, label = 'BEML');
plt.xlabel('gain');
plt.ylabel('Density');
plt.legend();

print("Daily gain of Glaxo")
print("-------------------")
print("Mean: ", round(glaxo_df.gain.mean(), 4))
print("Standard Deviation: ", round(glaxo_df.gain.std(), 4))

print("Daily gain of BEML")
print("------------------")
print("Mean: ", round(beml_df.gain.mean(), 4))
print("Standard Deviation: ", round(beml_df.gain.std(), 4))

beml_df.gain.describe()

"""# **Confidence Interval**"""

from scipy import stats
glaxo_df_ci= stats.norm.interval(0.95,
                                  loc =  glaxo_df.gain.mean(),
                                  scale = glaxo_df.gain.std())
print("Gain at 95% cofidence interval is: ", np.round(glaxo_df_ci, 4))

beml_df_ci= stats.norm.interval(0.95,
                                  loc =  beml_df.gain.mean(),
                                  scale = beml_df.gain.std())
print("Gain at 95% cofidence interval is: ", np.round(beml_df_ci, 4))